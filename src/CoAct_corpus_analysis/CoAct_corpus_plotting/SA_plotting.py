import matplotlib.pyplot as plt
import seaborn as sns 
import pandas as pd
import numpy as np
import os
from collections import Counter

def plot_frequency(question_df, tier, sa, out_dir):
    """ 
        Barplot showing for ONE social action category/type all the associations with other social action categories/types.

    Input:
        question_df: DataFrame with all the questions for the given social action tag (i.e. all questions labeled 'FS')
        tier: whether to show associations with SA_categories or SA_types (if the social action is a category you want to see the association with types and vice versa)
        sa: the social action abbreviation
        out_dir: directory to save plot image

    """
    sns.set_style("whitegrid")
    plt.figure()
    
    counter = Counter(question_df[tier]) #first count the SA categories in the df
    
    counter = {k: counter[k] for k in counter if type(k) is str} #exclude nan values
    counter_prct = {i: counter[i] / len(question_df[tier]) * 100.0 for i in counter} #turn counter into relative values
    count_values = [str(item) for item in counter.values()] #keep the count values for the bar labels
    
    #new df with the counters
    df = pd.DataFrame({tier: counter.keys(), 'Count': counter_prct.values()}, index = np.arange(0, len(counter_prct.keys()), 1))
    
    #plot relative counts
    ax = sns.barplot(data = df, x = tier, y = 'Count')
    ax.bar_label(ax.containers[0],  labels=[x for x in count_values])
    ax.set_ylabel("Occurrence (%)")
        
    ax.set_title(f'{tier} frequency of {sa} questions (n = {len(question_df)})')
    out_file = os.path.join(out_dir, f'{sa}_{tier}_frequency.png')  
    ax.get_figure().savefig(out_file)
    plt.close("all")



def plot_relative_onset(plotting_df, sa, tiers, out_dir):
    """
        Density estimate for ONE social action category/type of the relative onset (Signal onset - Question onset) for each facial signal/gesture tier.

    Input:
        plotting_df: DataFrame as generated by using the plot_preprocessing functions
        sa: the social action abbreviation
        tiers: facial signal/gesture tiers to show relative onset for
        out_dir: directory to save plot image

    """

    sns.set_style("whitegrid")
    
    fig, axs = plt.subplots(len(tiers), 1, figsize=(10,25))

    for i, ax in enumerate(axs.flatten()):
        f = plotting_df.loc[plotting_df['tier'] == tiers[i]]
        sns.kdeplot(data=f, x="onset_difference", hue="overlap_label", fill=True, alpha=.5, ax = ax)
        ax.axvline(x = 0, ls = ':', color = 'gray', alpha = .8)
        ax.set_title(tiers[i])
        ax.set_xlabel('Signal onset - Question onset (ms)')
        ax.set_xlim(-5000, 5000)
        
    plt.suptitle(f'Onset of Facial Signals Relative to Question Onset for {sa} Questions')    
    plt.tight_layout()
    plt.savefig(os.path.join(out_dir, f'{sa}_relative_onset.png'))
    plt.close("all")



def plot_facial_signal_frequency(plotting_df, sa, out_dir):

    """ 
        Barplot for ONE social action category/type showing the frequencies of overlapping facial signals
    
    Input:
        plotting_df: DataFrame as generated by using the plot_preprocessing functions
        sa: the social action abbreviation
        out_dir: directory to save plot image
    """

    sns.set_style("whitegrid")
    
    #count amount of facial signal overlaps
    counter = Counter(plotting_df['overlap_label'])
    tier_order = dict(zip(plotting_df['overlap_label'], plotting_df['tier']))
    
    counter = {k: counter[k] for k in counter if type(k) is str} #exclude nan values
    count_values = [str(item) for item in counter.values()] #keep the count values for the bar labels
    counter_prct = {i: counter[i] / len(plotting_df['overlap_label']) * 100.0 for i in counter} #turn into relative counts
    df = pd.DataFrame({'FS': counter_prct.keys(), 'Count': counter_prct.values(), 'Tier': tier_order.values()}, 
                      index = np.arange(0, len(counter_prct.keys()), 1))
    
    fig, ax = plt.subplots(figsize=(7,7))
    
    ax = sns.barplot(data = df, x = 'FS', y = 'Count', hue='Tier', dodge=False)

    for container in ax.containers:
        ax.bar_label(container, labels=[x for x in count_values])     
    ax.set_xlabel('Signal')
    ax.set_ylabel('Occurrence (%)')
    ax.set_ylim(0, 100)

    
    ax.tick_params(axis='x', labelrotation=90)
    ax.set_title(f'Occurrences of Facial Signal Overlaps for {sa} questions')
    
    out_file = os.path.join(out_dir, f'{sa}_facial_signal_frequency.png')  

    plt.tight_layout()
    plt.savefig(out_file)
    plt.close("all")



def plot_percentual_overlap(plotting_df, sa, out_dir):

    """ 
    Boxplot for ONE social action category/type showing the relative amount of temporal overlap of facial signals

    Input:
        plotting_df: DataFrame as generated by using the plot_preprocessing functions
        sa: the social action abbreviation
        out_dir: directory to save plot image
    """


    sns.set_style("whitegrid")

    fig, ax = plt.subplots(figsize=(19,7))
    plt.rcParams['text.usetex'] = True

    f = plotting_df.astype({'overlap_prct': float, 'overlap_label': str, 'tier': str})
    f = f[f['overlap_prct'] != 0.0]

    sns.boxplot(data=f, x="overlap_label", y="overlap_prct", hue="tier", dodge =False, width=.8,
                boxprops={"alpha": (.6)}, medianprops={"color": "coral"}, ax = ax)
    sns.stripplot(data=f, x="overlap_label", y="overlap_prct", hue="tier", linewidth=0.3, ax = ax)

    handles, labels = plt.gca().get_legend_handles_labels()
    ax.legend(handles[:int(len(handles)/2)], labels[:int(len(labels)/2)], loc='center right', bbox_to_anchor=(1.13, 0.5))
    ax.tick_params(axis='x', labelrotation=65)
    ax.set_xlabel('Facial Actions', fontsize = 13)
    ax.set_ylabel(r"Overlap in % ($\frac{dur\_overlap}{dur\_question} * 100$)", fontsize = 13)
    ax.set_title(f'Proportional Overlap Of {sa} Questions And Facial Signals', fontsize = 15)
    ax.tick_params(axis='both', which='major', labelsize=12)

    plt.tight_layout()
    plt.savefig(os.path.join(out_dir, f'{sa}_Overlap_amounts.png'))
    plt.close("all")


